sql执行顺序: FROM/JOIN/WHERE/GROUP BY/HAVING/SELECT/ORDER BY/LIMIT
事务:
    开启事务: BEGIN; start TRANSACTION; for update??
    结束事务: COMMIT; ROLLBACK;
    名词: mvcc acid
    隔离级别: 脏读, 幻读, 可重复读 读未提交, 读已提交
锁类型(InnoDB):
    #    表锁: FLUSH TABLES WITH READ LOCK; LOCK TABLES 表名 READ/WRITE; 读锁; 写锁; 元数据锁
    #    行锁: 加锁都是在索引上加锁; 非索引字段会查找索引字段然后加锁
    共享锁(S锁): 允许持有锁的事务读取行
    排它锁(X锁): 允许持有锁的事务更新或删除一行 #如果事务T1持有一个行r上的排它(X)锁，另一个事务T2无论读写请求都不会立即通过，而是需要等待T1释放在行r上的锁
    # 意向锁(Intention Locks) 是表级锁，用于指示事务稍后对表中的行需要哪种类型的锁(共享或独占)。
    意向共享锁(IS): 表示事务打算在表中的各个行上设置共享锁
    意向排他锁(IX): 表示事务打算对表中的各个行设置排他锁
    
    记录锁(Record Locks): 对索引记录上的单条记录加锁
    间隙锁(Gap Locks): 锁定一个范围，但不包括记录本身 # 间隙锁的主要目的是为了防止幻读(Phantom Reads)。
    临键锁(Next-key Locks): 是记录锁与间隙锁的结合，锁定一个范围，并且锁定记录本身。InnoDB的默认隔离级别(Repeatable Read)下使用临键锁来锁定查询的索引范围。
    插入意向锁(Insert Intention Locks): 在插入记录时，InnoDB会检查插入位置的间隙锁。如果其他事务已经持有间隙锁，那么InnoDB会允许第二个事务在间隙中插入一个记录，前提是这个事务必须持有插入意向锁。
    自增锁(Auto-inc Locks): 用于确保自增列(如AUTO_INCREMENT)在插入新记录时能够生成唯一的值。
死锁:
    死锁: 相互等待
    加锁: 线程/事务/event/lockId;
    排查:
        阻塞的线程/事务/eventId/lockId
        数据-lockId-> event -> 事务->线程
    解死锁条件:
    锁超时(事务超时): innodb_lock_wait_timeout

sql优化: explain
链接:
    from
    inner|left|right|outer|natual join
    union all
视图: 权限 增删改  数据的增删改 视图中的数据不直接来自基表,就不能修改
临时表:
    create temporary table table_name;
    # 临时表 https://zhuanlan.zhihu.com/p/356718127
    # 临时表和永久表类似，是需要插入到数据库储存在磁盘的临时区中，只有数据库连接断开MySQL自动删除临时表，或者drop 掉，才会消失。
    # 汇总维度相同时，巧用union，不用join。取各个临时表所需的字段，收集齐全后，一次group by。
    # 适用于：有很多复杂的关联子表查询。

其他:
    主从集群
    帮助文档,help
分组:
    group_concat
    select a,b from t group by a,b
    select字段基本跟在group by 后
    分组 聚合 having  分组后having再一次筛选